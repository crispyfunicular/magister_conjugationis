import pynooj
import json


def group_inflected_forms_by_lemma(inflected_forms):
    """Group the inflected forms by lemma (verb)"""
    lemmas = {}
    for inflected_form in inflected_forms:
        lemma = inflected_form["lemma"]
        if lemma not in lemmas:
            lemmas[lemma] = []
        lemmas[lemma].append(inflected_form)
    return lemmas


def check_inflected_forms(inflected_forms):
    """Verify that all the necessary mood/voice/tense/person combinations have been generated by NooJ"""
    lemmas = group_inflected_forms_by_lemma(inflected_forms)

    missing = {}  # Should exist but not found
    extras = {}  # Found but should not exist

    for inflected_forms in sorted(lemmas.values(), key=lambda x: x[0]["group"]):
        group = inflected_forms[0]["group"]
        lemma = inflected_forms[0]["lemma"]

        # Renvoie True si le verbe est déponent, False dans le cas contraire
        deponent = inflected_forms[0]["voice"] == "déponent"

        if group == 0:
            continue
        for mood in ["indicatif", "subjonctif", "impératif"]:

            # Si le verbe est déponent, il n'aura pas de voix active ou passive, et inversement
            # Il ne faut donc vérifier que la voix passive pour les verbes déponents,
            # et que les voix actives et passives pour les verbes non déponents.
            voices_to_check = ["déponent"] if deponent else ["actif", "passif"]
            for voice in voices_to_check:
                for tense in [
                    "présent",
                    "imparfait",
                    "futur",
                    "parfait",
                    "plus-que-parfait",
                    "futur antérieur",
                ]:
                    for person in [1, 2, 3, 4, 5, 6]:
                        key = f"group={group}, mood={mood}, voice={voice}, tense={tense}, person={person}"

                        if (
                            lemma == "timere"
                            and voice == "passif"
                            and (
                                tense == "parfait"
                                or tense == "plus-que-parfait"
                                or tense == "futur antérieur"
                            )
                        ):
                            continue

                        exist = False
                        for inflected_form in inflected_forms:
                            if (
                                inflected_form["person"] == person
                                and inflected_form["mood"] == mood
                                and inflected_form["voice"] == voice
                                and inflected_form["tense"] == tense
                            ):
                                exist = True

                        if (
                            mood == "subjonctif"
                            and (tense == "futur" or tense == "futur antérieur")
                        ) or (
                            mood == "impératif"
                            and (person not in [2, 5] or tense != "présent")
                        ):
                            if exist:
                                extras.setdefault(key, [])
                                extras[key].append(lemma)
                        else:
                            if not exist:
                                missing.setdefault(key, [])
                                missing[key].append(lemma)

    if len(missing) or len(extras):
        for key, lemmas in extras.items():
            print("should not exist:", key, lemmas)
        for key, lemmas in missing.items():
            print("missing:", key, lemmas)

            raise Exception(
                f"{len(missing)} missing forms and {len(extras)} extra forms"
            )


def deduplicate(verbs_lst: list[dict]) -> list[dict]:
    """
    example dicts:
    [{
        "latin": "amaberis",
        "lemma": "amare",
        "group": 1,
        "mood": "indicatif",
        "voice": "passif",
        "translation": [
        "aimer"
        ],
        "primitive tenses": "o, as, are, aui, atum",
        "tense": "futur",
        "person": 2
    },
    {
        "latin": "amabiris",
        "lemma": "amare",
        "group": 1,
        "mood": "indicatif",
        "voice": "passif",
        "translation": [
        "aimer"
        ],
        "primitive tenses": "o, as, are, aui, atum",
        "tense": "futur",
        "person": 2
    },
    {
        "latin": "duc",
        "lemma": "ducere",
        "group": 3,
        "mood": "impératif",
        "voice": "actif",
        "translation": [
        "conduire",
        "considérer comme"
        ],
        "primitive tenses": "o, is, ere, duxi, ductum",
        "tense": "présent",
        "person": 2
    },
    {
        "latin": "duce",
        "lemma": "ducere",
        "group": 3,
        "mood": "impératif",
        "voice": "actif",
        "translation": [
        "conduire",
        "considérer comme"
        ],
        "primitive tenses": "o, is, ere, duxi, ductum",
        "tense": "présent",
        "person": 2
    },
    ]

    return:
    [{
        "latin": "amaberis",
        "lemma": "amare",
        "group": 1,
        "mood": "indicatif",
        "voice": "passif",
        "translation": [
        "aimer"
        ],
        "primitive tenses": "o, as, are, aui, atum",
        "tense": "futur",
        "person": 2
    },
    {
        "latin": "duc",
        "lemma": "ducere",
        "group": 3,
        "mood": "imp",
        "voice": "actif",
        "translation": [
        "conduire",
        "considérer comme"
        ],
        "primitive tenses": "o, is, ere, duxi, ductum",
        "tense": "présent",
        "person": 2
    },]
    """

    verbs_lst_copy = []

    traits_dict = {}
    for inflected_form in verbs_lst:
        traits = (
            inflected_form["lemma"],
            inflected_form["mood"],
            inflected_form["voice"],
            inflected_form["tense"],
            inflected_form["person"],
            inflected_form.get("gender"),
        )

        traits_dict.setdefault(traits, []).append(inflected_form)

    for traits in traits_dict:
        if len(traits_dict[traits]) == 1:
            verbs_lst_copy.append(traits_dict[traits][0])
            continue

        irregular_forms = []
        for inflected_form in traits_dict[traits]:
            if inflected_form.get("irrégulier", False):
                irregular_forms.append(inflected_form)

        if len(irregular_forms) != 1:
            for t in traits_dict[traits]:
                print(t)
            raise Exception(
                f"Found {len(irregular_forms)} irregular forms for {traits}; there must be one and only one"
            )

        verbs_lst_copy.append(irregular_forms[0])

    return verbs_lst_copy


def main():
    verbs_lst = []
    dic_path = "NooJ/lat_verbes-flx.dic"
    print("reading verbs from NooJ dic:", dic_path)
    dics_nooj = pynooj.read_dic(dic_path)
    print(f"loaded {len(dics_nooj)} inflected forms (lines)")

    abreviations = {
        "masc": "masculin",
        "fem" : "féminin",
        "ind" : "indicatif",
        "sub" : "subjonctif",
        "imp" : "impératif",
        "act" : "actif",
        "pas" : "passif",
        "dep" : "déponent",
        "pres" : "présent",
        "impf" : "imparfait",
        "fut" : "futur",
        "pft" : "parfait",
        "pqp" : "plus-que-parfait",
        "fta" : "futur antérieur",
    }

    for dic_nooj in dics_nooj:
        dic_mc = {}

        # Only the few forms based on the supinum have gender marks.
        raw_gender = dic_nooj["traits"].get("GEN")
        dic_mc["gender"] = abreviations.get(raw_gender)

        # Mood, voice and tense
        # If we can't find the code in the abreviations dict, we keep its raw name.
        raw_mood = dic_nooj["traits"]["MOD"]
        dic_mc["mood"] = abreviations.get(raw_mood, raw_mood)

        raw_voice = dic_nooj["traits"]["VX"]
        dic_mc["voice"] = abreviations.get(raw_voice, raw_voice)

        raw_tense = dic_nooj["traits"]["TP"]
        dic_mc["tense"] = abreviations.get(raw_tense, raw_tense)

        try:
            dic_mc["latin"] = (
                dic_nooj["inflected form"].replace("v", "u").replace("j", "i")
            )
            dic_mc["lemma"] = dic_nooj["lemma"].replace("v", "u").replace("j", "i")
            dic_mc["group"] = int(dic_nooj["traits"]["GP"])
            dic_mc["translation"] = dic_nooj["traits"]["TRAD"].split(";")
            dic_mc["primitive tenses"] = dic_nooj["traits"]["PRIM"].replace(";", ", ")
            dic_mc["person"] = int(dic_nooj["traits"]["P"])
            if dic_mc["person"] not in range(1, 4):
                raise ValueError("Invalid form, the person is invalid")

            if dic_nooj["traits"]["NB"] == "pl":
                dic_mc["person"] += 3

            if dic_nooj["traits"].get("FORM") == "irr":
                dic_mc["irrégulier"] = True

            verbs_lst.append(dic_mc)
        except Exception as e:
            print("Error with:", dic_nooj)
            raise e

    # Sort by lemma > mood > voice > tense > person
    verbs_lst = sorted(
        verbs_lst,
        key=lambda x: (x["lemma"], x["mood"], x["voice"], x["tense"], x["person"]),
    )

    # Verify that all the necessary mood/voice/tense/person combinations have been generated by NooJ
    check_inflected_forms(verbs_lst)

    # Filter out some invalid inflected forms.
    filtered_verbs = deduplicate(verbs_lst)

    json_path = "verbs_latin.json"
    print(f"writing {len(filtered_verbs)} verbs to json file:", json_path)
    with open(json_path, "w", encoding="utf-8") as f:
        json.dump(filtered_verbs, f, indent=2, ensure_ascii=False)

    js_path = "web/verbs_latin.js"
    # Generated for static hosting: allows loading data without fetch/CORS on GitHub Pages.
    print(f"writing {len(filtered_verbs)} verbs to js file:", js_path)
    with open(js_path, "w", encoding="utf-8") as f:
        payload = "window.VERBS_LATIN = " + json.dumps(
            filtered_verbs, ensure_ascii=False
        )
        f.write(payload + ";\n")


if __name__ == "__main__":
    main()
